<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NumPy vs Python Lists – Speed, Memory, and Functionality</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --primary-blue: #2947a9;
      --accent-blue: #3498db;
      --section-bg: #f8faff;
      --code-bg: #f6f8fa;
      --output-bg: #fffbe7;
      --example-bg: #eafbf8;
      --warning-bg: #fff6e5;
      --formula-bg: #f3f6fc;
      --border-radius: 8px;
      --shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 0;
      background: #fcfdfd; color: #222;
    }
    .numpy-content {
      max-width: 900px;
      margin: 0 auto;
      padding: 32px 16px 41px 16px;
    }
    .main-title {
      text-align: center;
      font-size: 2.2em;
      font-weight: bold;
      color: var(--primary-blue);
      margin-bottom: 12px;
      border-bottom: 2px solid var(--accent-blue);
      padding-bottom: 12px;
      letter-spacing: 1px;
    }
    .section-title {
      font-size: 1.34em;
      font-weight: bold;
      color: #223377;
      letter-spacing: 1px;
      margin-top: 38px;
      margin-bottom: 18px;
      text-transform: uppercase;
    }
    .section {
      background: var(--section-bg);
      padding: 19px 18px 18px 18px;
      border-radius: var(--border-radius);
      margin-bottom: 26px;
      border-left: 5px solid var(--accent-blue);
      box-shadow: var(--shadow);
    }
    .key-points li {
      margin-bottom: 9px;
    }
    .quick-comparison {
      background: #ffffff;
      padding: 14px 18px;
      border-radius: var(--border-radius);
      border: 1px solid #e0e3ed;
      margin: 14px 0;
    }
    .quick-comparison td {
      padding: 6px 10px;
    }
    .quick-comparison tr:nth-child(2n+1) {
      background: #f5f7ff;
    }
    pre, code {
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 1em;
      line-height: 1.5;
    }
    pre {
      background: var(--code-bg);
      border-radius: var(--border-radius);
      padding: 13px 15px;
      border: 1px solid #e6e9ed;
      margin: 15px 0 5px 0;
      overflow-x: auto;
    }
    .output-title {
      font-weight: bold;
      color: #845201;
      margin: 10px 0 4px 0;
      font-family: 'Fira Mono', monospace;
    }
    .numpy-output {
      background: var(--output-bg);
      border-left: 5px solid #ffd600;
      border-radius: var(--border-radius);
      color: #845201;
      margin: 3px 0 18px 0;
      padding: 11px 15px;
      font-family: 'Fira Mono', 'Consolas', monospace;
      white-space: pre-wrap;
    }
    .example {
      background: var(--example-bg);
      border-left: 5px solid #43a047;
      border-radius: var(--border-radius);
      margin: 15px 0 12px 0;
      padding: 12px 15px;
      font-style: italic;
    }
    .warning {
      background: var(--warning-bg);
      border-left: 5px solid #ffa940;
      border-radius: var(--border-radius);
      color: #845201;
      margin: 15px 0 18px 0;
      padding: 13px 15px;
    }
    .numpy-q {
      font-weight: bold;
      color: #216ad3;
      margin-bottom: 7px;
    }
    .split-col {
      display: flex; flex-wrap: wrap; gap: 20px;
    }
    .split-col > div { flex: 1 1 380px; min-width: 250px; }
    .formula {
      background: var(--formula-bg);
      border-left: 5px solid var(--primary-blue);
      border-radius: var(--border-radius);
      font-family: 'Courier New', monospace;
      padding: 13px 15px;
      margin: 18px auto 20px auto;
      color: #23429e;
      font-size: 1.13em;
      text-align: center;
      max-width: 600px;
    }
    .img-example {
      margin: 14px 0 12px 0;
      max-width: 500px;
      display: block;
      margin-left: auto;
      margin-right: auto;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: var(--shadow);
    }
    img {
      max-width: 100%;
      height: auto;
    }
    @media (max-width: 700px) {
      .numpy-content { padding: 13px; }
      .main-title { font-size: 1.5em; }
      .split-col { flex-direction: column; gap:0px; }
      .formula { font-size: 0.95em; }
    }
    a { color: #1e3a8a; text-decoration: none; }
    a:hover { text-decoration: underline; }
    ul, ol { padding-left: 25px; }
    li { margin-bottom: 8px; }
  </style>
</head>
<body>
  <div class="numpy-content">
    <div class="main-title">NumPy Arrays vs Python Lists</div>

    <div class="section">
      <div class="section-title">Speed Comparison</div>
      <p><b>Python Lists: slow, loop-based</b></p>
      <pre><code># list
a = [i for i in range(10000000)]
b = [i for i in range(10000000,20000000)]
c = []
start = time.time()
for i in range(len(a)):
    c.append(a[i] + b[i])
print(time.time() - start)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">3.26 seconds (approx)</div>
      <p><b>NumPy Arrays: fast, vectorized</b></p>
      <pre><code># numpy
a = np.arange(10000000)
b = np.arange(10000000,20000000)
start = time.time()
c = a + b
print(time.time() - start)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">0.06 seconds (approx)</div>
      <p><b>Speedup:</b> <code>3.26 / 0.06 ≈ 54×</code></p>
    </div>

    <div class="section">
      <div class="section-title">Memory Efficiency</div>
      <pre><code># Python list
a = [i for i in range(10000000)]
sys.getsizeof(a)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">about 90 MB (varies by Python version, type overhead)</div>
      <pre><code># NumPy int8 array
a = np.arange(10000000, dtype=np.int8)
sys.getsizeof(a)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">about 10 MB (less than 1 byte per element)</div>
    </div>

    <div class="section">
      <div class="section-title">Quick Reference Table</div>
      <table class="quick-comparison">
        <tr><td><b>Feature</b></td><td><b>Python Lists</b></td><td><b>NumPy Arrays</b></td></tr>
        <tr><td><b>Element types</b></td><td>Can be mixed</td><td>Must be <i>homogeneous</i></td></tr>
        <tr><td><b>Size flexibility</b></td><td>Dynamic (grows/shrinks easily)</td><td>Fixed at creation</td></tr>
        <tr><td><b>Speed</b></td><td>Slow for numeric work (<b>loops</b>)</td><td><b>Fast</b> (vectorized ops)</td></tr>
        <tr><td><b>Memory</b></td><td>Higher overhead per element</td><td>Low, efficient for numbers</td></tr>
        <tr><td><b>Operations</b></td><td>Manual loops</td><td>Vectorized (+, *, math.sin, etc.)</td></tr>
        <tr><td><b>Advanced indexing</b></td><td>Basic – not vectorized</td><td>Fancy, boolean, slicing, vectorized</td></tr>
        <tr><td><b>Broadcasting</b></td><td>Not supported</td><td>Yes – automatic "stretching"</td></tr>
        <tr><td><b>Special math</b></td><td>No – manual</td><td>Yes (e.g. Fourier, linalg, statistics)</td></tr>
      </table>
    </div>

    <div class="section">
      <div class="section-title">Convenience: Advanced Indexing</div>
      <pre><code>a = np.arange(24).reshape(6,4)
print(a)</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]
 [16 17 18 19]
 [20 21 22 23]]
      </div>
      <pre><code>a[1, 2]       # Access single element</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">6</div>
      <pre><code>a[1:3, 1:3]   # Slicing – submatrix</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[5 6]
 [9 10]]
      </div>
      <pre><code>a[:, [0,2,3]] # Fancy indexing (columns 0,2,3)</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[ 0  2  3]
 [ 4  6  7]
 [ 8 10 11]
 [12 14 15]
 [16 18 19]
 [20 22 23]]
      </div>
    </div>

    <div class="section">
      <div class="section-title">Boolean Indexing</div>
      <pre><code>a = np.random.randint(1,100,24).reshape(6,4)
print(a)</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[13 80 25 56]
 [79 32 28 23]
 [11 77 21  2]
 [52 78 54 30]
 [53 73 84 61]
 [64 19 56 46]]
      </div>
      <pre><code>a[a > 50]                   # Numbers > 50</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[80 56 79 77 52 78 54 53 73 84 61 64 56 46]</div>
      <pre><code>a[a % 2 == 0]                # Even numbers</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[80 56 32 28 2 52 78 54 30 84 64 56 46]</div>
      <pre><code>a[(a > 50) & (a % 2 == 0)]  # >50 and even</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[80 56 52 78 54 84 64 56 46]</div>
      <pre><code>a[~(a % 7 == 0)]            # Not divisible by 7</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[80 25 56 79 32 23 11 77 2 52 78 54 30 53 73 84 61 64 19 56 46]
      </div>
    </div>

    <div class="section">
      <div class="section-title">Broadcasting: Automatic Array Stretching</div>
      <p>NumPy can perform elementwise operations on arrays of <b>different shapes</b> by "broadcasting" the smaller array to match the larger one.</p>
      <pre><code># Same shape
a = np.arange(6).reshape(2,3)
b = np.arange(6,12).reshape(2,3)
print(a + b)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[ 6  8 10]
 [12 14 16]]
      </div>
      <pre><code># Different shape – broadcasting!
a = np.arange(6).reshape(2,3)
b = np.arange(3).reshape(1,3)
print(a + b)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[0 2 4]
 [3 5 7]]
      </div>
      <p><b>Visualization of Broadcasting:</b></p>
      <div class="img-example">
        <img src="https://jakevdp.github.io/PythonDataScienceHandbook/figures/02.05-broadcasting.png" alt="Broadcasting explained visually">
      </div>
      <h3>Broadcasting Rules</h3>
      <ol>
        <li>
          <b>Same number of dimensions:</b> If arrays have different numbers of dimensions, prepend ones to the "smaller" array.
        </li>
        <li>
          <b>Matching or size-1 dimensions:</b> The sizes of each pair of dimensions (from right to left) must be equal, or one of them must be 1.
        </li>
      </ol>
      <h3>More Examples</h3>
      <pre><code>a = np.arange(12).reshape(4,3)
b = np.arange(3)
print(a + b)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[ 0  2  4]
 [ 3  5  7]
 [ 6  8 10]
 [ 9 11 13]]
      </div>
      <pre><code>a = np.arange(3).reshape(3,1)
b = np.arange(3).reshape(1,3)
print(a + b)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[0 1 2]
 [1 2 3]
 [2 3 4]]
      </div>
      <pre><code>a = np.array([1])
b = np.arange(4).reshape(2,2)
print(a + b)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[1 2]
 [3 4]]
      </div>
      <h3>Fail Case: Shapes cannot be broadcasted</h3>
      <pre><code>a = np.arange(16).reshape(4,4)
b = np.arange(4).reshape(2,2)
try: a + b
except ValueError: print("Cannot broadcast")
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">Cannot broadcast</div>
    </div>

    <div class="section">
      <div class="section-title">Working with Mathematical Formulas</div>
      <p>NumPy arrays work seamlessly with mathematical expressions—vectorized and fast!</p>
      <pre><code>a = np.arange(10)
np.sin(a)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427
 -0.2794155   0.6569866   0.98935825  0.41211849]
      </div>
      <pre><code># Sigmoid function
def sigmoid(array):
    return 1 / (1 + np.exp(-array))
a = np.arange(10)
sigmoid(a)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[0.5        0.73105858 0.88079708 0.95257413 0.98201379 0.99330715
 0.99752738 0.99908895 0.99966465 0.99987661]
      </div>
      <pre><code># Mean Squared Error with actual and predicted arrays
actual = np.random.randint(1, 50, 25)
predicted = np.random.randint(1, 50, 25)
def mse(actual, predicted):
    return np.mean((actual - predicted)**2)
mse(actual, predicted)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">(random, e.g.:) 336.88</div>
    </div>

    <div class="section">
      <div class="section-title">Handling Missing Values (NaN)</div>
      <pre><code>a = np.array([1, 2, 3, np.nan, 4, np.nan, 6])
a[~np.isnan(a)]
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[1. 2. 3. 4. 6.]</div>
    </div>

    <div class="section">
      <div class="section-title">Plotting Graphs</div>
      <p>NumPy works seamlessly with <code>matplotlib</code> for scientific visualization.</p>
      <pre><code>import matplotlib.pyplot as plt

x = np.linspace(-10, 10, 100)
y = x
plt.plot(x, y)        # Linear: y = x

y = x**2
plt.plot(x, y)        # Parabola: y = x²

y = np.sin(x)
plt.plot(x, y)        # Sine wave

y = x * np.log(x)
plt.plot(x, y)        # y = x*log(x)
y[50] = np.nan        # Avoid warning at x=0

y = 1 / (1 + np.exp(-x))
plt.plot(x, y)        # Sigmoid: y = 1/(1+e^-x)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">(see popup chart window, or use plt.show() in notebook)</div>
    </div>

    <div class="section">
      <div class="section-title">Meshgrids</div>
      <p>Create 2D grids for surfaces, contour plots, and more:</p>
      <pre><code>x = np.linspace(-2, 2, 5)
y = np.linspace(-2, 2, 5)
xx, yy = np.meshgrid(x, y)</code></pre>
    </div>

    <div class="section-title" style="margin-top:38px">Applied Exercises</div>

    <div class="section">
      <div class="numpy-q">Q1. Find the nearest element in an array to a given integer.</div>
      <pre><code>arr = np.array([10, 17, 24, 31, 38, 45, 52, 59])
a = 39
arr[abs(arr - a).argmin()]
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">38</div>
    </div>
    <div class="section">
      <div class="numpy-q">Q2. Replace multiples of 3 or 5 with 0.</div>
      <pre><code>arr = np.array([1, 2, 3, 4, 5, 6, 7, 9])
arr[(arr%3==0) | (arr%5==0)] = 0
arr
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[1 2 0 4 0 0 7 0]</div>
    </div>
    <div class="section">
      <div class="numpy-q">Q3a. Double elements at given indexes</div>
      <pre><code>arr = np.arange(10)
indexes = [0, 3, 4, 9]
arr[indexes] *= 2
arr
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[ 0  1  2  6  8  5  6  7  8 18]</div>
      <div class="numpy-q">Q3b. Repeat array elements as per array length</div>
      <pre><code>array = np.array([1, 2, 3])
indexes = np.repeat(np.arange(len(array)), len(array))
array[indexes]
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">[1 1 1 2 2 2 3 3 3]</div>
    </div>
    <div class="section">
      <div class="numpy-q">Q4. Fill NaN values with the most frequent non-NaN value</div>
      <pre><code>arr = np.array([[1, 2, np.nan], [4, 2, 6], [np.nan, np.nan, 5]])
freq = np.unique(arr[~np.isnan(arr)], return_counts=True)
most_common = freq[0][np.argmax(freq[1])]
arr[np.isnan(arr)] = most_common
arr
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[1. 2. 2.]
 [4. 2. 6.]
 [2. 2. 5.]]
      </div>
    </div>
    <div class="section">
      <div class="numpy-q">Q5a. Find missing (NaN) values (boolean mask)</div>
      <pre><code>arr = np.array([[3, 2, np.nan, 1], [10, 12, 10, 9], [5, np.nan, 1, np.nan]])
np.isnan(arr)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[False False  True False]
 [False False False False]
 [False  True False  True]]
      </div>
      <div class="numpy-q">Q5b. Fill missing values with 0</div>
      <pre><code>np.nan_to_num(arr)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[ 3.  2.  0.  1.]
 [10. 12. 10.  9.]
 [ 5.  0.  1.  0.]]
      </div>
    </div>
    <div class="section">
      <div class="numpy-q">Q6. Construct Cauchy matrix from X and Y</div>
      <div class="formula">C<sub>ij</sub> = 1/(x_i - y_j)</div>
      <pre><code>x = np.array([1,2,3,4]).reshape(-1, 1)
y = np.array([5,6,7])
1 / (x - y)
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
[[-0.25       -0.2        -0.16666667]
 [-0.33333333 -0.25       -0.2       ]
 [-0.5        -0.33333333 -0.25      ]
 [-1.         -0.5        -0.33333333]]
      </div>
    </div>
    <div class="section">
      <div class="numpy-q">Q7. Plot y = tanh(x) = (eˣ - e⁻ˣ)/(eˣ + e⁻ˣ)</div>
      <div class="formula">y = (eˣ - e⁻ˣ)/(eˣ + e⁻ˣ)</div>
      <pre><code>import matplotlib.pyplot as plt
x = np.linspace(-30, 30, 1000)
y = (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x))
plt.plot(x, y)
plt.title('tanh activation function')
plt.xlabel('x')
plt.ylabel('y')
plt.show()
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">(plots in your Python environment/jupyter notebook)</div>
    </div>
    <div class="section">
      <div class="numpy-q">Q8. Plot y = √(36 - (x - 4)²) + 2, x ∈ [-2, 10]</div>
      <div class="formula">y = √(36 - (x - 4)²) + 2</div>
      <pre><code>x = np.linspace(-2, 10, 100)
y = np.sqrt(36 - (x-4)**2) + 2
plt.plot(x, y)
plt.ylim(0, 10)
plt.show()
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">(plots semicircle centered at (4,8) in your Python environment)</div>
    </div>
    <div class="section">
      <div class="numpy-q">Q9. Check if two array shapes can be broadcasted</div>
      <pre><code>def check_broadcast(ashape, bshape):
    # Make shapes same length by prepending 1s
    ashape = (1,) * (max(len(bshape), len(ashape)) - len(ashape)) + ashape
    bshape = (1,) * (max(len(ashape), len(bshape)) - len(bshape)) + bshape
    # Check each dimension
    for a, b in zip(ashape, bshape):
        if a != b and a != 1 and b != 1:
            return False
    return True

check_broadcast((3,2,2), (2,2))  # True
check_broadcast((3,2), (3,4))    # False
</code></pre>
      <div class="output-title">Output:</div>
      <div class="numpy-output">
check_broadcast((3,2,2), (2,2)) → True
check_broadcast((3,2), (3,4)) → False
      </div>
    </div>
    <div class="section">
      <h3>Conclusion</h3>
      <p><b>NumPy arrays</b> are vastly superior for numerical computing—faster, more memory-efficient, and packed with convenient features. <b>Python lists</b> are flexible, but for data science, machine learning, and scientific work, <b>NumPy</b> is the foundation.</p>
    </div>
    <p style="text-align:center; font-size:0.9em; margin-top:1.5em;"><b>Need more? See the <a href="https://numpy.org/doc/" target="_blank">NumPy documentation</a>.</b></p>
  </div>
</body>
</html>